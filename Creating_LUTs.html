<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2018 (Released Feb 1, 2018) -->
<HTML>
<HEAD>
<TITLE>Creating LUTs</TITLE>
<META NAME="description" CONTENT="Creating LUTs">
<META NAME="keywords" CONTENT="cinematic-color">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2018">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="cinematic-color.css">

<LINK REL="next" HREF="GPU_Implementations.html">
<LINK REL="previous" HREF="Half_Float_LUTs.html">
<LINK REL="up" HREF="LUTs_Transforms.html">
<LINK REL="next" HREF="GPU_Implementations.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html2443"
  HREF="GPU_Implementations.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2439"
  HREF="LUTs_Transforms.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2433"
  HREF="Half_Float_LUTs.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2441"
  HREF="Contents.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html2444"
  HREF="GPU_Implementations.html">GPU Implementations</A>
<B> Up:</B> <A NAME="tex2html2440"
  HREF="LUTs_Transforms.html">LUTs and Transforms</A>
<B> Previous:</B> <A NAME="tex2html2434"
  HREF="Half_Float_LUTs.html">Half Float LUTs</A>
 &nbsp; <B>  <A NAME="tex2html2442"
  HREF="Contents.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H2><A NAME="SECTION00645000000000000000">
Creating LUTs</A>
</H2>
<P>
<BIG CLASS="LARGE">LUTs are fundamentally lists of output values, corresponding to input values, and most LUT formats store these as plain text lists or XML. Some binary formats exist, usually for efficiency in hardware LUT implementations, and for these, it is often simpler to create a human-readable LUT first and then convert with suitable utility software to the binary form.
</BIG>
<P>
<BIG CLASS="LARGE">A CMS Image generated by Nuke. This pattern is only 9^3 (dividing R, G &amp; B into 9 levels each)
for clarity, resulting in 9 × 9 × 9 = 729 different colored patches
Grading and compositing systems include the functionality to read such images and generate LUTs, either from transforms applied by their own processes, or externally, in which case the nature of the process may be unknown, or even secret.
</BIG>
<P>
<BIG CLASS="LARGE">If the transform to be applied is a known mathematical one, perhaps a specific color space transform, LUTs can be baked using Colour Science for Python, for example. A simple code example to do this for an unspecified transform where output = f(input) is shown below:
import colour
LUT = colour.LUT3D(name='LUT Name')
LUT.domain = ([[-0.07, -0.07, -0.07], [1.09, 1.09, 1.09]])
LUT.comments = ['First comment', 'Second comment']
LUT.table = colour.LUT3D.linear_table(size=33, domain=LUT.domain)
LUT.table = f(LUT.table)
colour.write_LUT(LUT, '/path/to/lut/file.cube')
</BIG>
<P>
<BIG CLASS="LARGE">This procedure is all that is needed when the LUT in question is to be applied to an output referred image, or a log image in the 0-1 range. However when a shaper is required, to create a LUT for HDR image data, the situation is more complex. Decisions need to be made, and there is no one correct solution. Sometimes the possible range of the input data is known – if it comes from a specific camera perhaps – but it is often necessary to decide on a sensible input range, and accept that data outside this range may be clipped. It is also useful to consider what data may be clipped in the final output, so as not to waste input range on unnecessary values. For example, if baking a LUT to apply the ACES RRT plus an SDR ODT to ACES linear data, any shaper which includes input values above 16.3 is wasteful, as these will be clipped by the ODT. A balance needs to be struck between covering a sufficient range, and not spreading the available table entries too thinly, which can result in distortions from interpolation if the shaper does not include enough points for the range. It can be helpful to calculate forward and reverse shapers and pass a linear ramp through a concatenation of the two, looking for deviations from a straight line (particularly near black) after the round trip.
</BIG>
<P>
<BIG CLASS="LARGE">A linear ramp transformed from ACEScct to ACEScg and back using a 12 bit 1D LUT.
In the plot above, because of the wide range covered by ACEScct, the first interval of the linear to log LUT covers the ACEScct range 0.0-0.304 (-0.007-0.047 linear). Interpolating linearly for values in this large interval, when they are in fact logarithmically spaced, results in this “kink”. For the full range covered by ACEScct, a 16 bits are needed before the distortion becomes negligible with uniformly spaced samples. The alternative is to use a non-uniform shaper if the LUT format supports that. The OCIO ACES config, for example, takes the latter approach by including only log to linear shaper LUTs, and using them in the reverse direction for linear to log conversions. The Python code snippet below generates a Cinespace LUT which has a logarithmically spaced input domain and a linearly spaced output table and thus will not show the issue.
</BIG>
<P>
<BIG CLASS="LARGE">from colour import LUT1D, write_LUT
from colour.models import log_decoding_ACEScct
</BIG>
<P>
<BIG CLASS="LARGE">table = np.linspace(0, 1, 4096)
domain = log_decoding_ACEScct(table)
LUT = LUT1D(table, 'Linear to ACEScct', domain)
write_LUT(LUT, '/path/to/lut_file.csp')
</BIG>
<P>
<BIG CLASS="LARGE">While GUI tools, such as LightSpace and Lattice, are available and can create and convert both 1D and 3D LUTs, they cannot work with LUTs which include both a 1D shaper and a 3D cube in the same file. Neither can Nuke’s GenerateLUT node. Therefore it is necessary either to manually split the process under consideration into the 1D and 3D components, and bake separate LUTs, or else use command line tools such as OCIO’s ociobakelut which have options to select a shaper space and range for formats which support combined 1D + 3D LUTs. For example, the command below will create a Cinespace LUT which will apply the ACES RRT plus Rec. 709 ODT:
</BIG>
<P>
<BIG CLASS="LARGE">ociobakelut -inputspace "ACES - ACES2065-1" -iconfig "/Library/Application Support/OpenColorIO/aces_1.0.3/config.ocio" -shaperspace "Utility - Log2 48 nits Shaper" -outputspace "Output - Rec.709" -format cinespace ACES_RRT_709_ODT.csp
</BIG>
<P>
<BIG CLASS="LARGE">Using Colour Science for Python, as previously, it is possible to write the shaper and cube components of a transform to a Resolve .cube or Cinespace .csp LUT. The code listed below creates a shaper ranging from six stops below mid-grey to six stops above it, and a cube which applies the transform which is the difference between the shaper and f(input):
</BIG>
<P>
<BIG CLASS="LARGE">import colour
import numpy as np
</BIG>
<P>
<BIG CLASS="LARGE">domain = [0.18 * 2 ** -6, 0.18 * 2 ** 6]
shaper = colour.LUT1D(size=16384, domain=domain)
shaper.table = 0.5 + np.log2(shaper.table / 0.18) / 12
</BIG>
<P>
<BIG CLASS="LARGE"># Inverse shaper used only for cube calculation
def inverse_shaper(x):
    return 0.18 * 2 ** (12*(x - 0.5))
</BIG>
<P>
<BIG CLASS="LARGE">cube = colour.LUT3D(name='LUT Name', size=33)
</BIG>
<P>
<BIG CLASS="LARGE"># Apply the transform to the identity cube
# pre-transformed by the inverse of the shaper
cube.table = f( inverse_shaper(cube.table) )
</BIG>
<P>
<BIG CLASS="LARGE">LUT = colour.LUTSequence(shaper, cube)
colour.write_LUT(LUT, '/path/to/lut/file.cube')
</BIG>
<P>
<BIG CLASS="LARGE">Because most LUTs are text files, it is possible to process and convert them with simple text processing scripts. For example, while ociobakelut can create a LUT including a shaper in the Houdini format which can be used in the OCIOFileTransform node of Nuke, this same LUT file cannot be applied in DaVinci Resolve. Resolve supports combined 1D + 3D LUTs, but the format required is not currently available with ociobakelut in OCIO v1. However the Houdini and Resolve combined LUT formats are sufficiently similar, that the necessary conversion can be performed easily with a script, or even manually using a spreadsheet application.
</BIG>
<P>
<BIG CLASS="LARGE">Houdini .lut version (not usable size) of the ociobakelut output above:
DaVinci Resolve .cube version of the same LUT:
Version		3
Format		any
Type		3D+1D
From		0.001989 16.291740
To		0.000000 1.000000
Black		0.000000
White		1.000000
Length		3 9
LUT:
Pre 
	0.000000
	0.769326
	0.846195
	0.891173
	0.923091
	0.947849
	0.968078
	0.985183
	1.000000

3D 
	0.000000 0.000000 0.000000
	0.534865 0.000000 0.000000
	1.000000 0.254877 0.543403
	0.000000 0.446770 0.000000
	0.462596 0.411305 0.000000
	1.000000 0.253674 0.542072
	0.290448 1.000000 0.636457
	0.289485 1.000000 0.636227
	1.000000 1.000000 0.736428
	0.000000 0.000000 0.400418
	0.527788 0.000000 0.398828
	1.000000 0.252359 0.671285
	0.000000 0.422871 0.384992
	0.389530 0.389530 0.389530
	1.000000 0.252446 0.670820
	0.279933 1.000000 0.680195
	0.278750 1.000000 0.680725
	1.000000 1.000000 0.783296
	0.000000 0.062706 1.000000
	0.000000 0.062739 1.000000
	1.000000 0.340477 1.000000
	0.000000 0.062698 1.000000
	0.000000 0.062714 1.000000
	1.000000 0.339629 1.000000
	0.000000 1.000000 1.000000
	0.000000 1.000000 1.000000
	1.000000 1.000000 1.000000
 
LUT_1D_SIZE 9
LUT_1D_INPUT_RANGE 0.001989 16.291740
</BIG>
<P>
<BIG CLASS="LARGE">LUT_3D_SIZE 3
LUT_3D_INPUT_RANGE 0.0 1.0
</BIG>
<P>
<BIG CLASS="LARGE">0.000000 0.000000 0.000000
0.769326 0.769326 0.769326
0.846195 0.846195 0.846195
0.891173 0.891173 0.891173
0.923091 0.923091 0.923091
0.947849 0.947849 0.947849
0.968078 0.968078 0.968078
0.985183 0.985183 0.985183
1.000000 1.000000 1.000000
</BIG>
<P>
<BIG CLASS="LARGE">0.000000 0.000000 0.000000
0.534865 0.000000 0.000000
1.000000 0.254877 0.543403
0.000000 0.446770 0.000000
0.462596 0.411305 0.000000
1.000000 0.253674 0.542072
0.290448 1.000000 0.636457
0.289485 1.000000 0.636227
1.000000 1.000000 0.736428
0.000000 0.000000 0.400418
0.527788 0.000000 0.398828
1.000000 0.252359 0.671285
0.000000 0.422871 0.384992
0.389530 0.389530 0.389530
1.000000 0.252446 0.670820
0.279933 1.000000 0.680195
0.278750 1.000000 0.680725
1.000000 1.000000 0.783296
0.000000 0.062706 1.000000
0.000000 0.062739 1.000000
1.000000 0.340477 1.000000
0.000000 0.062698 1.000000
0.000000 0.062714 1.000000
1.000000 0.339629 1.000000
0.000000 1.000000 1.000000
0.000000 1.000000 1.000000
1.000000 1.000000 1.000000
</BIG>
<P>
<BIG CLASS="LARGE">Note the similarity between the tables. Only the headers and the number of columns in the shaper LUT differ.
</BIG>
<P>
<BIG CLASS="LARGE">Particularly when baking a combined LUT, testing is necessary to ensure that the resulting LUT is supported and correctly applied in the intended application. Different implementations support various LUT specifications to varying degrees, and it is not unheard of for LUTs to appear to be correctly read, but for the parsing to get out of step, producing a result which may superficially match the intent for some, but not all images. For example, the Iridas and Resolve .cube LUT formats are broadly similar, but the tokens for input range differ, and may not be read properly (or at all) by some LUT parsers. It is always wise, where possible, to compare the result of the LUT with a reference implementation of the transform on a variety of images.
</BIG>
<P>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html2443"
  HREF="GPU_Implementations.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2439"
  HREF="LUTs_Transforms.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2433"
  HREF="Half_Float_LUTs.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2441"
  HREF="Contents.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html2444"
  HREF="GPU_Implementations.html">GPU Implementations</A>
<B> Up:</B> <A NAME="tex2html2440"
  HREF="LUTs_Transforms.html">LUTs and Transforms</A>
<B> Previous:</B> <A NAME="tex2html2434"
  HREF="Half_Float_LUTs.html">Half Float LUTs</A>
 &nbsp; <B>  <A NAME="tex2html2442"
  HREF="Contents.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->

</BODY>
</HTML>
